{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":""},{"location":"#nfdi-matwerk-ontology-mwo","title":"NFDI MatWerk Ontology (MWO)","text":"<p>NFDI-MatWerk aims to establish a digital infrastructure for Materials Science and Engineering (MSE), fostering improved data sharing and collaboration. This repository provides comprehensive documentation for NFDI MatWerk Ontology (MWO) v3.0.0, a foundational framework designed to structure research data and enhance interoperability within the MSE community. To ensure compliance with top-level ontology standards, MWO v3.0.0 is aligned with the Basic Formal Ontology (BFO) and incorporates the modular approach of the NFDIcore mid-level ontology, enriching metadata through standardized classes and properties. The mwo addresses key aspects of MSE research data, including the NFDI-MatWerk community structure, covering task areas, infrastructure use cases, projects, researchers, and organizations. It also describes essential NFDI resources, such as software, workflows, ontologies, publications, datasets, metadata schemas, instruments, facilities, and educational materials. Additionally, mwo represents NFDI-MatWerk services, academic events, courses, and international collaborations. As the foundation for the MSE Knowledge Graph, mwo facilitates efficient data integration and retrieval, promoting collaboration and knowledge representation across MSE domains. This digital transformation enhances data discoverability, reusability, and accelerates scientific exchange, innovation, and discoveries by optimizing research data management and accessibility.</p> <p>The ontology\u2019s latest version is always accessible at: mwo.owl.</p>"},{"location":"#ontology-metadata","title":"Ontology metadata","text":"<ul> <li>Title: NFDI MatWerk Ontology. </li> <li>Abbreviation: mwo. </li> <li>Namespace: http://purls.helmholtz-metadaten.de/mwo.  </li> <li>Prefix: mwo. </li> <li>Language: OWL. </li> <li>Repository: https://github.com/ISE-FIZKarlsruhe/mwo </li> <li>Current version (mwo v3): http://purls.helmholtz-metadaten.de/mwo/3.0.0. </li> <li>Previous version (mwo v2, 2024.03.11): http://purls.helmholtz-metadaten.de/mwo/2.0.0. </li> <li>Previous version (mwo v1, 2023.02.16): http://purls.helmholtz-metadaten.de/mwo/1.0.1. </li> <li>Creators: Hossein Beygi Nasrabadi, J\u00f6rg Waitelonis, Ebrahim Norouzi, Kostiantyn Hubaiev, Harald Sack. </li> <li>Contributors: Abril Az\u00f3car Guzm\u00e1n, Ahmad Zainul Ihsan, Said Fathalla, Angelika Gedsun, Amir Laadhar, Stefan Sandfeld, Volker Hofmann, Felix Fritzen. </li> <li>Related project: NFDI MatWerk. </li> <li>Funding: Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) under the National Research Data Infrastructure \u2013 NFDI 38/1 \u2013 project number 460247524. </li> <li>License: https://creativecommons.org/publicdomain/zero/1.0/. </li> <li>Citation: Hossein Beygi Nasrabadi, J\u00f6rg Waitelonis, Ebrahim Norouzi, Kostiantyn Hubaiev, Harald Sack. NFDI MatWerk Ontology (mwo). Revision: v3.0.0. Retrieved from: https://github.com/ISE-FIZKarlsruhe/mwo.  </li> </ul> <p>Here you will find information about:  - Introduction, scopes, features, and application of the ontology. - Ontology structure, reused upper-level ontologies, and ontology key concepts. - Ontology patterns and use-cases. - Different versions of the ontology. - how to contribute. - Acknowledgements. - References and related publications.  </p>"},{"location":"acknowledgements/","title":"Acknowledgements","text":"<p>The NFDI MatWek project funded by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) under the National Research Data Infrastructure \u2013 NFDI 38/1 \u2013 project number 460247524.</p>"},{"location":"cite/","title":"How to cite MWO","text":""},{"location":"contributing/","title":"Contributing","text":"<p>If you are a researcher, developer, or industry professional interested in contributing to the development, support, or reuse of the NFDI MatWerk Ontology (MWO), we invite you to explore and engage with our project repository. Your participation will help enhance the ontology\u2019s capabilities and ensure its continuous improvement for the MSE community.</p> <p>We welcome contributions to the NFDI MatWerk Ontology (MWO)! To get involved: - Visit our GitHub repository: Explore the latest developments and ongoing discussions. - Create an issue: Report bugs, suggest improvements, or request new features.  </p> <p>Your contributions will help improve MWO for the MSE community. Join us on GitHub and be part of the development!</p>"},{"location":"intro/","title":"Introduction","text":"<p>The National Research Data Infrastructure (NFDI) is a German initiative established in 2020 to systematically manage scientific and research data. It aims to provide long-term data storage, backup, and accessibility while enabling the networking of research data both nationally and internationally. By developing a sustainable and standardized research data infrastructure across various disciplines, NFDI enhances data management practices and ensures the long-term availability of valuable research outputs [1, 2]. As a specialized consortium within the NFDI framework, NFDI-MatWerk (National Research Data Infrastructure for Materials Science and Engineering) aims to develop a digital infrastructure for Materials Science and Engineering (MSE). Funded by the German Research Foundation (DFG), it focuses on the integration and standardization of decentralized data, metadata, workflows, and ontologies to enhance interoperability and reproducibility in MSE research. By incorporating both experimental and simulation data, along with their associated metadata, NFDI-MatWerk provides essential tools and frameworks for efficient data management, long-term accessibility, and improved collaboration within the field [3]. The NFDI-MatWerk Ontology (MWO) is a domain-level ontology that designed to standardize terminology, enhance data integration, and improve collaboration in MSE. One of the key objectives mwo is to develop a knowledge graph that integrates FAIR digital objects, enabling the structured representation of materials and processing parameters. By ensuring the seamless integration of decentralized data and workflows, MWO plays a crucial role in enhancing interoperability and reproducibility across MSE research. The NFDI MatWerk Ontology (MWO) is a unified framework developed by the Task Area Ontologies for Materials Science (TA-OMS) within the NFDI-MatWerk initiative [4].</p>"},{"location":"intro/#goals","title":"Goals","text":"<p>The ontology development task area within NFDI-MatWerk aims to establish a structured and standardized approach to managing MSE data. By creating a comprehensive and interoperable ontology, this effort seeks to enhance data integration, discovery, and reuse while ensuring alignment with community standards and evolving research needs. The key goals of this initiative include [4]: - Develop Unified Materials Ontology: Create a comprehensive ontology that standardizes the representation of materials data, including individualized ontologies for specific tools and workflows developed within the community. - Ensure Interoperability: Facilitate the integration and interoperability of materials data by providing a common framework for data descriptions and metadata alignment. - Support Efficient Data Discovery: Enhance the ability of researchers to discover and access relevant materials data through standardized and easily searchable metadata. - Promote Data Integration and Reuse: Enable efficient integration and reuse of data across various platforms and research activities by implementing consistent ontological frameworks. - Implement a Knowledge Graph: Develop and maintain a knowledge graph that allows for the retrieval of data based on their metadata, improving data accessibility and usability. - Align with Community Standards: Ensure that the ontology aligns with existing community standards and practices, facilitating broad acceptance and adoption within the materials science community. - Adapt to Emerging Needs and Technologies: Continuously update and refine the ontology to address emerging research needs and incorporate new technologies and methodologies in materials science. - Enhance Metadata Quality: Improve the quality of metadata by providing guidelines and tools for creating detailed and accurate data descriptions.  </p>"},{"location":"intro/#ontology-scope","title":"Ontology scope","text":"<p>As a domain ontology, mwo serves as a foundational framework for the MSE community, structuring research data and enhancing accessibility and interoperability. The key aspects of this ontology\u2019s scope include: A) Consortium structure: NFDI MatWerk consortium, its structures (task areas, infrastructure use cases, and participant projects), researches, and organizations,  B) NFDI resources: software, data portals, metadata schemas, scientific publications, published datasets, workflows, and ontologies, C) NFDI MatWerk services, events, educational coerces, and international collaborations, D) MSE related instruments, facilities, materials, processes, and properties.  </p>"},{"location":"intro/#mwo-v300-key-features","title":"mwo v3.0.0 key features.","text":"<ul> <li>Alignment with standards: Conforming ISO/IEC 21838-2:2021 standard [5], mwo v3 builds upon the Basic Formal Ontology (BFO) top level ontology. </li> <li>Reusability and extensibility: mwo 3.0 builds upon the NFDIcore v3 mid-level ontology and integrates with Platform MaterialDigital ontology (PMDco v3). Furthermore, mwo v3 incorporates entities from various other ontologies like IAO, QUDT, SWO, DCAT, FOAF, and Schema, ensuring broad applicability and cross-domain connectivity. </li> <li>Adaptive and community-driven development: The ontology is continuously extended and maintained through community-driven development, ensuring it adapts to the evolving needs of MSE research data. </li> <li>Standardized Ontology Development and Maintenance:  the mwo v3 is released and documented using the OBO-based Ontology Development Kit (ODK) [6], which ensures a standardized development workflow aligned with OBO Foundry best practices. ODK provides automated quality control, enhancing ontology consistency and reducing errors. It enables seamless integration with other OBO ontologies, supports FAIR principles, and streamlines versioning and release management. Additionally, it facilitates collaborative development through GitHub-based workflows, ensuring continuous improvement and broad adoption within the MSE research community. </li> </ul>"},{"location":"intro/#applications","title":"Applications","text":"<p>At the moment, mwo is being used as a basis for developing several application ontologies for the MSE research data management. These ontologies will be listed here as soon as their release.  Furthermore, mwo is the basis for the MSE knowledge graph (MSE-KG) [7]. It is a structured digital resource designed to integrate and provide unified access to distributed and heterogeneous research data within the NFDI-MatWerk consortium and the broader MSE community. Serving as the backend data resource for the NFDI-MatWerk portal, it enables researchers to explore community structures, infrastructure, and scientific data through a standardized and continuously updated platform. Built on W3C technologies and deployed using Wikibase, the MSE-KG facilitates semantic data integration, enhances discoverability, and supports ontology-based knowledge representation in materials science and engineering.</p>"},{"location":"ontology/","title":"Ontology structure","text":"<p>The NFDI MatWerk Ontology (MWO) is a domain-level ontology designed to enhance data integration and retrieval, fostering collaboration and improving knowledge representation across MSE domains. It covers essential aspects of MSE research data, including the NFDI-MatWerk community structure, key NFDI resources, services, and MSE-related research data description. By enabling the integration of diverse data sources and supporting complex research data workflows, MWO bridges MSE research metadata with concepts from upper-level ontologies.</p>"},{"location":"ontology/#reused-upper-level-ontologies","title":"Reused upper-level ontologies","text":"<p>Building the mwo based on standardized upper-level ontologies provides a well-designed and standardized semantic structure, ensuring clear definitions of entities and their relationships. These ontologies enhance interoperability across different domains, support ontology development, and promote consistency in knowledge representation. The following upper-level ontologies have been incorporated for mwo development: - Basic Formal Ontology (BFO 2020) [8]: BFO was selected as the top-level ontology due to its well-structured design, broad applicability, and ability to integrate with various ontologies. As a foundational framework, BFO provides abstract, cross-domain semantic structures, ensuring comprehensive integration and compliance with top-level ontology standards. Its adherence to the ISO/IEC 21838-2 standard [5] further enhances interoperability in developed ontologies, facilitating knowledge representation, data exchange, and interdisciplinary collaboration. - NFDIcore ontology (v3): As a mid-level ontology, NFDIcore plays a central role in structuring and integrating research data across consortia. NFDIcore features a modular structure for improved interoperability among NFDI consortia. It provides a shared vocabulary that represents both the organizational structure of the NFDI and the diverse datasets contributed by project partners. The ontology encompasses key concepts such as organizations, consortia, projects, datasets, research outputs, geographical locations, and technical standards. These structured representations enable efficient data management, integration, and reuse across disciplines [9]. - Platform MaterialDigital Core Ontology (PMDco v3): The Platform MaterialDigital core ontology (PMDco) is a mid-level ontology in the MSE domain. The PMDco provides bridging mid-level concepts for detailed description of processes, experiments, and computational workflows enabling the reproducibility of process and materials data. These general MSE concepts are designed to be extendable for specific applications within application ontologies. The PMDco is designed in a collaborative effort within the MaterialDigital initiative and intended to be easily used by MSE domain experts [10]. - Artifact Ontology (IAO): Since BFO 2020 (the version currently adopted by NFDIcore) is not fully supported by IAO [11], some relevant IAO concepts could not be reused. In such cases, NFDIcore-specific classes have been introduced, such as dataset, document and identifier. - Other reused ontologies and vocabularies like Quantities, Units, Dimensions, and Types (QUDT) ontology [12], Software Ontology (SWO) [13], Friend of a Friend (FOAF) [14], Data Catalog Vocabulary (DCAT) [15], and schema.org vocabulary [16].</p>"},{"location":"ontology/#key-concepts","title":"Key concepts","text":""},{"location":"ontology/#classes","title":"Classes","text":"<p>Below figure illustrates the development of MWO concepts by reusing upper-level ontologies. The top-level (red-colored entities at the upper side) is based on BFO, while the mid-level consists of NFDI Core (blue), PMD (yellow), and IAO (purple). The domain-level, represented in green, corresponds to MWO-specific concepts. Notably, most MWO extensions appear under the bfo:GenericallyDependentContinuant class, indicating a strong focus on information-related research data descriptions. This hierarchical structure ensures alignment with foundational ontological principles while accommodating domain-specific needs. </p> <p></p> <p>Regarding the scope of the ontology, the key concepts in MWO v3.0 are categorized into four main groups. Below is an overview of these core concepts. The full list of concepts is available in the generated ontology description: https://nfdi.fiz-karlsruhe.de/mwo/. A- Consortium Structure: Covers the NFDI MatWerk consortium, including MatWerk TA, IUC, PP organizations, as well as the specifications of involved people and organizations.   </p> <p>A) NFDI MatWerk Consortium: NFDI-MatWerk will focus on the research areas of materials science and materials engineering. The key challenges in these fields are the digital mapping of materials and their process and loading parameters. This process touches core aspects of scientific ways of working starting with scientific exchange, data handling and the resulting technological possibilities. The digital transformation of materials science and materials engineering is an opportunity to promote, structure and optimize this exchange - provided that transparent communication standards are created. This fundamental change is therefore being tackled in a joint effort by the consortium and the specialist community. - MatWerk Project: A MatWerk project is a project within the NFDI MatWerk consortium that involves coordinated research, development, or infrastructure activities aimed at advancing materials science and engineering through data-driven methodologies and digitalization. - MatWerk Participating project (PP): Participant Projects (PPs) are projects by NFDI-MatWerk partners that address specific scientific and technological challenges, providing practical examples and feedback for the development and validation of the infrastructure. - Funding specification: A funding specification is a directive information entity that provides structured guidelines, policies, and requirements for securing, managing, and allocating financial resources for various activities, projects, or organizations. - Persons, organizations and their roles: a wide varieties of roles in project and related person and organization entities were created in subcleaase of nfdicore:Agent and nfdicore:AgentRole.</p> <p>B) NFDI resources including implemented tools, software, publications, datasets, data portals, and metadata specifications. -   Materials science subject areas classified in 10 groups of computational materials science, data driven material science, materials characterization, materials deformation processes, materials design, materials mechanical behavior, materials microstructural, materials processing, materials surface science, and materials thermodynamics. -   Data portals subclasses of data analysis portal, linked data portal, material science database, material science knowledge base, repository hosting data portal, research data repository, and software repository. -   Software subclasses like data analysis software, electronic lab notebook, image processing software, operating system, simulation software, and workflow management software. -   Documents (e.g., presentation document) and publication types like conference abstract, conference paper, conference poster, and, journal article. -   Document parts like authors/creators/contributors list and institutions list. -   Metadata specification, a detailed document that describes metadata structures, guidelines, and usage policies for standardization and adoption. -   Datasets (experimental, simulation and reference dataset). A Reference Dataset is a dataset that serves as a benchmark or standardized collection of data used for validation, comparison, and reproducibility in scientific research and engineering applications. -   Information access specification, a directive information entity that defines the policies, conditions, and mechanisms governing the accessibility of digital or physical information resources for users or organizations.</p> <p>C) Service, events, educational coerces, and collaborations:  -   Collaboration: A collaboration is a process in which multiple entities, such as individuals, organizations, or institutions, work together toward shared goals, contributing resources, expertise, or services to achieve mutual benefits. -   Infrastructure Use Case (IUC): a service product that defines a specific application scenario, requirement, or implementation of research infrastructure, demonstrating its functionality, benefits, and impact in a given scientific or industrial domain. -   Event implementation specification: a directive information entity that provides formal guidelines, constraints, and details on how an event should be executed. It specifies the mode of implementation, including logistical, technical, and procedural aspects required to carry out an event successfully. -   Status specification: a directive information entity that defines the current state, progress, or condition of an entity, process, or project based on predefined criteria and operational guidelines. -   Event frequency datum: describes how often an events occurs within a given time interval. -   Sustainability datum: represents the duration or persistence of a process, system, or resource over time. It defines how long an entity is expected to remain viable or functional.</p> <p>D) Specification of MSE-related materials, instruments, and facilities: While most of the MSE-related concepts of mwo were derived from PMDco ontologies, some MSE-related entities were also represented in mwo to fascinate description of materials, instruments, and facilities. For example; -   Large scale facility: A Large-Scale Facility is a service product that provides specialized, high-capacity infrastructure for scientific research, engineering, or computational purposes, supporting large-scale experiments, simulations, and data analysis in various domains. -   Material designation: Material designation is an identifier assigned to a material to specify its name, Id, classification, composition, or standardized reference in scientific, engineering, or industrial contexts.</p>"},{"location":"ontology/#object-properties","title":"Object properties","text":"<p>Ontologies based on BFO are generally extended by adding classes, while extensive modifications to object properties are discouraged to maintain consistency and interoperability. Studies show that ontology developers using a foundational ontology tend to add more classes and fewer object properties than those who do not. However, in some cases, new object properties may be necessary. Based on MatWerk community request, we added just specific object properties of developed_by, codeveloped_by, and adapted_by to shortcut the relation between a NFDI resource and independent continuant (e.g., TA/IUC/PP organization). These properties support respond to competency questions like which tools are 'developed', 'co developed', or 'adopted' by NFDI MatWerk consortium.</p>"},{"location":"ontology/#data-properties","title":"Data properties","text":"<p>A limited number of data properties are used in mwo which more derived from NFDIcore ontology (e.g., has value, has url, and file extension) and FOAF (title, name, given name, family name).  Below data properties were also defined by mwo:  -   has acronym: A relation between an information content entity and its specific acronym. -   has id: A relation between an information content entity and its specific ID.</p>"},{"location":"ontology/#annotation-properties","title":"Annotation properties","text":"<p>No annotation property was created in mwo, as all required annotation properties are well developed by dc, dcterms, rdfs, owl, skos, etc.</p>"},{"location":"ontology/#individuals","title":"Individuals","text":"<ul> <li>NFDI MatWerk Consortium instances: MatWerk task area (TA) organization, MatWerk participant project (PP) organization, and MatWerk infrastructure use case (IUC) organization,</li> <li>Academic titles: Prof., Dr., M.Sc., etc. </li> <li>Status specifications: active, cancelled, finished, and paused statuses,</li> <li>Information access specifications: open, paywall or restricted accesses,</li> <li>Event implementation specifications: on-site, online and hybrid implementations.</li> </ul>"},{"location":"patterns/","title":"Patterns and use cases","text":"<p>This section showcases example ontology design patterns (ODPs) developed using MWO and their application in representing practical MSE-based use cases, highlighting their capacity to enable scalable, reusable, and semantically robust knowledge frameworks. </p>"},{"location":"patterns/#ontology-design-patterns","title":"Ontology design patterns:","text":"<p>ODPs are reusable and modular components that encapsulate best practices for solving common challenges in ontology development. Furthermore, ODPs may be used to create SHACL shapes to include constraints in a knowledge representation. By following usage patterns, ontology users and developers can ensure uniformity, clarity, and reusability in their models. The example structural, content-based, and presentation ODPs were designed to define foundational arrangements of entities, address domain-specific knowledge, and optimize user interaction with ontologies. </p>"},{"location":"patterns/#pattern-1-process-agent-role","title":"Pattern 1: Process- Agent- Role","text":"<p>The diagram illustrates the relationships between Occurrent, Independent Continuant, and Specifically Dependent Continuant in the context of BFO and MWO ontologies. Within NFDIcore, a process often serves to establish connections between agents and information content entities, defining the roles of agents with respect to the involved information content entities. Likewise, in NFDIcore, the concept of Agents extends to both organizations and persons, serving as independent continuants within the BFO ontology. Agents are essential for management of research data resources, and include entities such as research institutions, consortia, universities, companies, and individual researchers or data scientists. While bfo:Process represents an Occurrent (i.e., an event or process), nfdicore:Agent represents an Independent Continuant, which can act as a participant in a process, and bfo:Role represents a Specifically Dependent Continuant, which depends on an independent continuant. The object properties of has_participant, realizes, and bearer_of are all from BFO. This pattern shows how roles are assigned to agents participating in processes, maintaining alignment with BFO principles while extending them for MWO-specific applications.</p> <p></p>"},{"location":"patterns/#pattern-2-service","title":"Pattern 2: Service","text":"<p>The pattern represents a structured approach to modeling service processes within NFDIcore and MWO, following BFO principles. It illustrates how a service process involves an organization as a participant, which realizes a service provider role. The process generates an output (nfdicore:ServiceProduct), which realizes a service product role and is linked to a service specification (nfdicore:ServiceSpecification) through nfdicore:hasSpecification. This follows Pattern 1 for describing service processes, ensuring a structured linkage between processes, participants, roles, outputs, and specifications. </p> <p></p>"},{"location":"patterns/#pattern-3-resource-contact-point","title":"Pattern 3: Resource- Contact point","text":"<p>The pattern represents identifying the contact point of an NFDI resource. In NFDIcore, resources are continuants that encompass various digital creative works, such as datasets, collections, metadata, and offered products/services like data portals, data curation, and data digitization. Here, an NFDI resource is linked to a contact point agent through nfdicore:hasContactPoint. The agent, participating in a process, realizes a contact point role, which is further denoted by specific contact details, like a name, email address, and website. This structured approach ensures that each NFDI resource can be linked to a responsible contact agent with clearly defined roles and accessible communication channels, enhancing transparency and usability in NFDI-related services and digital infrastructures.</p> <p></p>"},{"location":"patterns/#pattern-4-resource-implementation","title":"Pattern 4: Resource implementation","text":"<p>This diagram models the implementation relationship between an resource and its associated agent. The MatWerk project is represented as a process that involves a participant (like MatWerk TA, IUC, or PP) realizing a role. The output of this project is an NFDI resource (e.g., dataset, tool, software, or digital service). The property mwo:implementedBy provides a shortcut for linking the NFDI resource to the process that produced it, simplifying the tracking of tools, services, and digital outputs within the NFDI MatWerk consortium. This property was specifically introduced to address competency questions such as which tools were developed, co-developed, or adopted in an organization, enabling a more structured representation of research outputs and their contributors. </p> <p></p>"},{"location":"patterns/#pattern-5-resource-description","title":"Pattern 5: Resource description","text":"<p>The pattern presents a detailed model for describing an NFDI resource (such as software, an ontology, a document, a publication, or a service) by incorporating multiple Information Content Entities (ICEs). Each NfdiResource is linked to various attributes through object properties, which are primarily refinements of iao:is_about. These attributes can include a wide range of ICEs like title, abbreviation, subject area, file format, specification, version, license, citation, standard, repository, external identifiers, and various textual entities (e.g., author information, keywords, requirements, and affiliations). Furthermore, NFDIcore defines specific sub-properties of iao:is_about, such as hasDataset, hasFileFormat, and hasLicence, to create a structured and semantically rich representation of digital resources.  </p> <p></p>"},{"location":"patterns/#pattern-6-value-specification","title":"Pattern 6: Value specification","text":"<p>This pattern illustrates how data values associated with various ICEs are represented using the nfdicore:hasValue data property. In general, all data values related to the above-mentioned patterns can be linked to ICEs via nfdicore:hasValue, ensuring a structured approach to representing numerical or textual values. More specifically, for measurement data, the measured value is assigned using nfdicore:hasValue, while its corresponding measurement unit is linked to a unit instance of iao:MeasurementUnitLabel via mwo:hasMeasurementUnitLabel. </p> <p></p>"},{"location":"patterns/#pattern-7-temporal-region","title":"Pattern 7: Temporal region","text":"<p>This pattern illustrates the representation of temporal regions within the BFO framework, distinguishing between zero-dimensional and one-dimensional temporal regions. A bfo:ZeroDimensionalTemporalRegion represents an instant in time, such as the start or end of an event, while a bfo:OneDimensionalTemporalRegion represents a time interval that has a duration and within which events can occur. The relationships between temporal entities, such as occupies_temporal_region, has_first_instance, and has_last_instance, are derived from BFO. To represent data associated with these temporal regions, mwo:SpecificationDatum, a subclass of iao:DataItem, is used. These data points, such as start date, end date, duration, and frequency, are linked to their values using the nfdicore:hasValue data property.</p> <p></p>"},{"location":"patterns/#pattern-8-material-entity-description","title":"Pattern 8: Material entity description","text":"<p>The diagram provides a structured representation for Material Entities (such as devices or materials) descriptions. A Material Entity is connected to its relating processes or projects via bfo:participates_in or nfdicore:isOutputOf, indicating its involvement or production within a project. The realized aspects of a Material Entity, such as its role, disposition, and function, are represented through bfo:bearer_of and bfo:material_basis_of objerct properties. Additionally, agents (organizations, persons, service providers, or contact points) linked to the material entity are included via nfdicore:hasAgent. The location of the material entity is captured using nfdicore:Place, while its structural composition is detailed with obo:has_continuant_part or obo:has_member_part. Furthermore, various ICEs are used to describe the material entity\u2019s metadata, including identifiers, specifications, and other descriptive attributes, with nfdicore:hasSpecification linking the entity to its specifications. </p> <p></p>"},{"location":"patterns/#use-cases","title":"Use cases","text":"<p>To illustrate the practical utility of ODPs, we presented several use cases within the MSE domain, such as representing metadata for materials, instruments, large-scale facilities, researchers, organizations, educational events, resources, datasets, data portals, and material research software. Through these cases, we emphasize how ODPs facilitate development by offering standardized templates for tasks such as hierarchy modeling, semantic relationship management, and data source integration, while also supporting ontology-driven solutions that are technically sound and adaptable to changing domain requirements.</p>"},{"location":"patterns/#use-case-1-nfdi-matwerk-organization","title":"Use case 1- NFDI MatWerk organization","text":""},{"location":"patterns/#use-case-2-nfdi-matwerk-persons","title":"Use case 2- NFDI MatWerk persons","text":""},{"location":"patterns/#use-case-3-nfdi-matwerk-task-area-ta","title":"Use case 3- NFDI MatWerk task area (TA)","text":""},{"location":"patterns/#use-case-4-software-description","title":"Use case 4- Software description","text":""},{"location":"patterns/#use-case-5-event-description","title":"Use case 5- Event description","text":""},{"location":"patterns/#use-case-5-large-scale-facility-description","title":"Use case 5- large scale facility description","text":""},{"location":"refs/","title":"References and publications","text":""},{"location":"refs/#references","title":"References","text":"<p>[1] https://www.nfdi.de/ [2] https://www.dfg.de/en/research-funding/funding-initiative/nfdi  [3] https://nfdi-matwerk.de/ [4] https://nfdi-matwerk.de/project/structure/task-areas/ta-oms  [5] ISO/IEC 21838-2:2021, Information technology \u2014 Top-level ontologies (TLO)Part 2: Basic Formal Ontology (BFO), https://www.iso.org/standard/74572.html.   [6] Ontology Development Kit (ODK): https://incatools.github.io/ontology-development-kit/ [7] MSE Knowledge graph: https://msekg-nfdi-matwerk-02.web.vulcanus.otc.coscine.dev/matwerk/   [8] Basic Formal Ontology (BFO 2020): https://github.com/BFO-ontology/BFO-2020   [9] NFDIcore ontology (v3): https://github.com/ISE-FIZKarlsruhe/nfdicore/tree/main  [10] Platform MaterialDigital Core Ontology (PMDco v3): https://github.com/materialdigital/core-ontology   [11] Artifact Ontology (IAO): https://github.com/information-artifact-ontology/IAO  [12] Quantities, Units, Dimensions, and Types (QUDT) ontology: https://qudt.org/  [13] Software Ontology (SWO): https://github.com/allysonlister/swo  [14] Friend of a Friend (FOAF): http://xmlns.com/foaf/spec/  [15] Data Catalog Vocabulary (DCAT): https://www.w3.org/TR/vocab-dcat-3/  [16] schema.org vocabulary:  https://schema.org/    </p>"},{"location":"refs/#presentation-resources","title":"Presentation resources","text":"<ul> <li>DeRSE2025, 2025.02.26, Karlsruhe, Germany. Link: https://doi.org/10.5281/zenodo.14960658. </li> <li>MaterialsWeek 2025, 2025.04.03, Goethe-Universit\u00e4t Frankfurt, Frankfurt am Main, Germany. Link:  </li> <li>EMMC International Workshop 2025, 2025.04.08-10, Vienna, Austria. Link:  </li> <li>ESWC 2025, 2025.06.01-05, Portoroz, Slovenia. Link:  </li> <li>ICME 2025, 2025.06.15-19, Anaheim (CA), USA. Link:  </li> <li>Euromat2025, 2025.09.14-18, Granada, Spain. Link:   </li> </ul>"},{"location":"refs/#publications","title":"Publications","text":"<ul> <li>Advanced Engineering Material, 2025. Link:</li> </ul>"},{"location":"versions/","title":"Versions","text":""},{"location":"versions/#stable-release-versions","title":"Stable release versions.","text":"<p>The latest version of the ontology can always be found at: mwo.owl and mwo.ttl</p>"},{"location":"versions/#variants","title":"Variants.","text":"<p>The ontology is shipped in three varaints, each as OWL (.owl) and Turtle serializations (.ttl): - full: mwo-full.ttl, mwo.ttl (default).  - base: mwo-base.ttl - simple: [mwo-simple.ttl] (https://github.com/ISE-FIZKarlsruhe/mwo/blob/main/mwo-simple.ttl).  The \"full release\" artefact contains all logical axioms, including inferred subsumptions. All imports and components are merged into the full release artefact to ensure easy version management. The full release represents most closely the actual ontology as it was intended at the time of release, including all its logical implications. The \"base file\" is a specific release flavour. It reflects the intention of the ontology author for the official (publicly released) representation of the ontologies \"base entities\". \"Base entities\" are entities that are defined (\"owned\") by the ontology. The representation includes the intended public metadata (annotations), and classification (subClassOf hierarchy), including any statements where a base entity is the subject.   The \"simple\" artefact only contains a simple existential graph of the terms defined in the ontology. This corresponds to the state before logical definitions and imports. For example, the only logical axioms are of the form CL1 subClassOf CL2 or CL1 subClassOf R some CL3 where R is any objectProperty and CLn is a class. The simple variant only contains the essential classes and no imports.   The ontology \"main\" file mwo.ttl contains the full version.</p>"},{"location":"versions/#editors-version","title":"Editors' version","text":"<p>Editors of this ontology should use the edit version. From this version all release variants are derived by the build workflows. Editors version: src/ontology/mwo-edit.owl</p>"},{"location":"odk-workflows/","title":"Default ODK Workflows","text":"<ul> <li>Daily Editors Workflow</li> <li>Release Workflow</li> <li>Manage your ODK Repository</li> <li>Setting up Docker for ODK</li> <li>Imports management</li> <li>Managing the documentation</li> <li>Managing your Automated Testing</li> </ul>"},{"location":"odk-workflows/ContinuousIntegration/","title":"Introduction to Continuous Integration Workflows with ODK","text":"<p>Historically, most repos have been using Travis CI for continuous integration testing and building, but due to runtime restrictions, we recently switched a lot of our repos to GitHub actions. You can set up your repo with CI by adding  this to your configuration file (src/ontology/mwo-odk.yaml):</p> <pre><code>ci:\n  - github_actions\n</code></pre> <p>When updateing your repo, you will notice a new file being added: <code>.github/workflows/qc.yml</code>.</p> <p>This file contains your CI logic, so if you need to change, or add anything, this is the place!</p> <p>Alternatively, if your repo is in GitLab instead of GitHub, you can set up your repo with GitLab CI by adding  this to your configuration file (src/ontology/mwo-odk.yaml):</p> <pre><code>ci:\n  - gitlab-ci\n</code></pre> <p>This will add a file called <code>.gitlab-ci.yml</code> in the root of your repo.</p>"},{"location":"odk-workflows/EditorsWorkflow/","title":"Editors Workflow","text":"<p>The editors workflow is one of the formal workflows to ensure that the ontology is developed correctly according to ontology engineering principles. There are a few different editors workflows:</p> <ol> <li>Local editing workflow: Editing the ontology in your local environment by hand, using tools such as Prot\u00e9g\u00e9, ROBOT templates or DOSDP patterns.</li> <li>Completely automated data pipeline (GitHub Actions)</li> <li>DROID workflow</li> </ol> <p>This document only covers the first editing workflow, but more will be added in the future</p>"},{"location":"odk-workflows/EditorsWorkflow/#local-editing-workflow","title":"Local editing workflow","text":"<p>Workflow requirements:</p> <ul> <li>git</li> <li>github</li> <li>docker</li> <li>editing tool of choice, e.g. Prot\u00e9g\u00e9, your favourite text editor, etc</li> </ul>"},{"location":"odk-workflows/EditorsWorkflow/#1-create-issue","title":"1. Create issue","text":"<p>Ensure that there is a ticket on your issue tracker that describes the change you are about to make. While this seems optional, this is a very important part of the social contract of building an ontology - no change to the ontology should be performed without a good ticket, describing the motivation and nature of the intended change.</p>"},{"location":"odk-workflows/EditorsWorkflow/#2-update-main-branch","title":"2. Update main branch","text":"<p>In your local environment (e.g. your laptop), make sure you are on the <code>main</code> (prev. <code>master</code>) branch and ensure that you have all the upstream changes, for example:</p> <pre><code>git checkout main\ngit pull\n</code></pre>"},{"location":"odk-workflows/EditorsWorkflow/#3-create-feature-branch","title":"3. Create feature branch","text":"<p>Create a new branch. Per convention, we try to use meaningful branch names such as: - issue23removeprocess (where issue 23 is the related issue on GitHub) - issue26addcontributor - release20210101 (for releases)</p> <p>On your command line, this looks like this:</p> <pre><code>git checkout -b issue23removeprocess\n</code></pre>"},{"location":"odk-workflows/EditorsWorkflow/#4-perform-edit","title":"4. Perform edit","text":"<p>Using your editor of choice, perform the intended edit. For example:</p> <p>Prot\u00e9g\u00e9</p> <ol> <li>Open <code>src/ontology/mwo-edit.owl</code> in Prot\u00e9g\u00e9</li> <li>Make the change</li> <li>Save the file</li> </ol> <p>TextEdit</p> <ol> <li>Open <code>src/ontology/mwo-edit.owl</code> in TextEdit (or Sublime, Atom, Vim, Nano)</li> <li>Make the change</li> <li>Save the file</li> </ol> <p>Consider the following when making the edit.</p> <ol> <li>According to our development philosophy, the only places that should be manually edited are:<ul> <li><code>src/ontology/mwo-edit.owl</code></li> <li>Any ROBOT templates you chose to use (the TSV files only)</li> <li>Any DOSDP data tables you chose to use (the TSV files, and potentially the associated patterns)</li> <li>components (anything in <code>src/ontology/components</code>), see here.</li> </ul> </li> <li>Imports should not be edited (any edits will be flushed out with the next update). However, refreshing imports is a potentially breaking change - and is discussed elsewhere.</li> <li>Changes should usually be small. Adding or changing 1 term is great. Adding or changing 10 related terms is ok. Adding or changing 100 or more terms at once should be considered very carefully.</li> </ol>"},{"location":"odk-workflows/EditorsWorkflow/#4-check-the-git-diff","title":"4. Check the Git diff","text":"<p>This step is very important. Rather than simply trusting your change had the intended effect, we should always use a git diff as a first pass for sanity checking.</p> <p>In our experience, having a visual git client like GitHub Desktop or sourcetree is really helpful for this part. In case you prefer the command line:</p> <pre><code>git status\ngit diff\n</code></pre>"},{"location":"odk-workflows/EditorsWorkflow/#5-quality-control","title":"5. Quality control","text":"<p>Now it's time to run your quality control checks. This can either happen locally (5a) or through your continuous integration system (7/5b).</p>"},{"location":"odk-workflows/EditorsWorkflow/#5a-local-testing","title":"5a. Local testing","text":"<p>If you chose to run your test locally:</p> <pre><code>sh run.sh make IMP=false test\n</code></pre> <p>This will run the whole set of configured ODK tests on including your change. If you have a complex DOSDP pattern pipeline you may want to add <code>PAT=false</code> to skip the potentially lengthy process of rebuilding the patterns.</p> <pre><code>sh run.sh make IMP=false PAT=false test\n</code></pre>"},{"location":"odk-workflows/EditorsWorkflow/#6-pull-request","title":"6. Pull request","text":"<p>When you are happy with the changes, you commit your changes to your feature branch, push them upstream (to GitHub) and create a pull request. For example:</p> <pre><code>git add NAMEOFCHANGEDFILES\ngit commit -m \"Added biological process term #12\"\ngit push -u origin issue23removeprocess\n</code></pre> <p>Then you go to your project on GitHub, and create a new pull request from the branch, for example: https://github.com/INCATools/ontology-development-kit/pulls</p> <p>There is a lot of great advise on how to write pull requests, but at the very least you should: - mention the tickets affected: <code>see #23</code> to link to a related ticket, or <code>fixes #23</code> if, by merging this pull request, the ticket is fixed. Tickets in the latter case will be closed automatically by GitHub when the pull request is merged. - summarise the changes in a few sentences. Consider the reviewer: what would they want to know right away. - If the diff is large, provide instructions on how to review the pull request best (sometimes, there are many changed files, but only one important change).</p>"},{"location":"odk-workflows/EditorsWorkflow/#75b-continuous-integration-testing","title":"7/5b. Continuous Integration Testing","text":"<p>If you didn't run and local quality control checks (see 5a), you should have Continuous Integration (CI) set up, for example: - Travis - GitHub Actions</p> <p>More on how to set this up here. Once the pull request is created, the CI will automatically trigger. If all is fine, it will show up green, otherwise red.</p>"},{"location":"odk-workflows/EditorsWorkflow/#8-community-review","title":"8. Community review","text":"<p>Once all the automatic tests have passed, it is important to put a second set of eyes on the pull request. Ontologies are inherently social - as in that they represent some kind of community consensus on how a domain is organised conceptually. This seems high brow talk, but it is very important that as an ontology editor, you have your work validated by the community you are trying to serve (e.g. your colleagues, other contributors etc.). In our experience, it is hard to get more than one review on a pull request - two is great. You can set up GitHub branch protection to actually require a review before a pull request can be merged! We recommend this.</p> <p>This step seems daunting to some hopefully under-resourced ontologies, but we recommend to put this high up on your list of priorities - train a colleague, reach out!</p>"},{"location":"odk-workflows/EditorsWorkflow/#9-merge-and-cleanup","title":"9. Merge and cleanup","text":"<p>When the QC is green and the reviews are in (approvals), it is time to merge the pull request. After the pull request is merged, remember to delete the branch as well (this option will show up as a big button right after you have merged the pull request). If you have not done so, close all the associated tickets fixed by the pull request.</p>"},{"location":"odk-workflows/EditorsWorkflow/#10-changelog-optional","title":"10. Changelog (Optional)","text":"<p>It is sometimes difficult to keep track of changes made to an ontology. Some ontology teams opt to document changes in a changelog (simply a text file in your repository) so that when release day comes, you know everything you have changed. This is advisable at least for major changes (such as a new release system, a new pattern or template etc.).</p>"},{"location":"odk-workflows/ManageDocumentation/","title":"Updating the Documentation","text":"<p>The documentation for MWO is managed in two places (relative to the repository root):</p> <ol> <li>The <code>docs</code> directory contains all the files that pertain to the content of the documentation (more below)</li> <li>the <code>mkdocs.yaml</code> file contains the documentation config, in particular its navigation bar and theme.</li> </ol> <p>The documentation is hosted using GitHub pages, on a special branch of the repository (called <code>gh-pages</code>). It is important that this branch is never deleted - it contains all the files GitHub pages needs to render and deploy the site. It is also important to note that the gh-pages branch should never be edited manually. All changes to the docs happen inside the <code>docs</code> directory on the <code>main</code> branch.</p>"},{"location":"odk-workflows/ManageDocumentation/#editing-the-docs","title":"Editing the docs","text":""},{"location":"odk-workflows/ManageDocumentation/#changing-content","title":"Changing content","text":"<p>All the documentation is contained in the <code>docs</code> directory, and is managed in Markdown. Markdown is a very simple and convenient way to produce text documents with formatting instructions, and is very easy to learn - it is also used, for example, in GitHub issues. This is a normal editing workflow:</p> <ol> <li>Open the <code>.md</code> file you want to change in an editor of choice (a simple text editor is often best). IMPORTANT: Do not edit any files in the <code>docs/odk-workflows/</code> directory. These files are managed by the ODK system and will be overwritten when the repository is upgraded! If you wish to change these files, make an issue on the ODK issue tracker.</li> <li>Perform the edit and save the file</li> <li>Commit the file to a branch, and create a pull request as usual. </li> <li>If your development team likes your changes, merge the docs into main branch.</li> <li>Deploy the documentation (see below)</li> </ol>"},{"location":"odk-workflows/ManageDocumentation/#deploy-the-documentation","title":"Deploy the documentation","text":"<p>The documentation is not automatically updated from the Markdown, and needs to be deployed deliberately. To do this, perform the following steps:</p> <ol> <li>In your terminal, navigate to the edit directory of your ontology, e.g.:    <code>cd mwo/src/ontology</code></li> <li>Now you are ready to build the docs as follows:    <code>sh run.sh make update_docs</code> Mkdocs now sets off to build the site from the markdown pages. You will be asked to<ul> <li>Enter your username</li> <li>Enter your password (see here for using GitHub access tokens instead)   IMPORTANT: Using password based authentication will be deprecated this year (2021). Make sure you read up on personal access tokens if that happens!</li> </ul> </li> </ol> <p>If everything was successful, you will see a message similar to this one:</p> <p><code>INFO    -  Your documentation should shortly be available at: https://ISE-FIZKarlsruhe.github.io/MatWerk_ontology/</code> 3. Just to double check, you can now navigate to your documentation pages (usually https://ISE-FIZKarlsruhe.github.io/MatWerk_ontology/).     Just make sure you give GitHub 2-5 minutes to build the pages!</p>"},{"location":"odk-workflows/ReleaseWorkflow/","title":"The release workflow","text":"<p>The release workflow recommended by the ODK is based on GitHub releases and works as follows:</p> <ol> <li>Run a release with the ODK</li> <li>Review the release</li> <li>Merge to main branch</li> <li>Create a GitHub release</li> </ol> <p>These steps are outlined in detail in the following.</p>"},{"location":"odk-workflows/ReleaseWorkflow/#run-a-release-with-the-odk","title":"Run a release with the ODK","text":"<p>Preparation:</p> <ol> <li>Ensure that all your pull requests are merged into your main (master) branch</li> <li>Make sure that all changes to main are committed to GitHub (<code>git status</code> should say that there are no modified files)</li> <li>Locally make sure you have the latest changes from main (<code>git pull</code>)</li> <li>Checkout a new branch (e.g. <code>git checkout -b release-2021-01-01</code>)</li> <li>You may or may not want to refresh your imports as part of your release strategy (see here)</li> <li>Make sure you have the latest ODK installed by running <code>docker pull obolibrary/odkfull</code></li> </ol> <p>To actually run the release, you:</p> <ol> <li>Open a command line terminal window and navigate to the src/ontology directory (<code>cd mwo/src/ontology</code>)</li> <li>Run release pipeline:<code>sh run.sh make prepare_release -B</code>. Note that for some ontologies, this process can take up to 90 minutes - especially if there are large ontologies you depend on, like PRO or CHEBI.</li> <li>If everything went well, you should see the following output on your machine: <code>Release files are now in ../.. - now you should commit, push and make a release on your git hosting site such as GitHub or GitLab</code>.</li> </ol> <p>This will create all the specified release targets (OBO, OWL, JSON, and the variants, ont-full and ont-base) and copy them into your release directory (the top level of your repo).</p>"},{"location":"odk-workflows/ReleaseWorkflow/#review-the-release","title":"Review the release","text":"<ol> <li>(Optional) Rough check. This step is frequently skipped, but for the more paranoid among us (like the author of this doc), this is a 3 minute additional effort for some peace of mind. Open the main release (mwo.owl) in you favourite development environment (i.e. Prot\u00e9g\u00e9) and eyeball the hierarchy. We recommend two simple checks: <ol> <li>Does the very top level of the hierarchy look ok? This means that all new terms have been imported/updated correctly.</li> <li>Does at least one change that you know should be in this release appear? For example, a new class. This means that the release was actually based on the recent edit file. </li> </ol> </li> <li>Commit your changes to the branch and make a pull request</li> <li>In your GitHub pull request, review the following three files in detail (based on our experience):<ol> <li><code>mwo.obo</code> - this reflects a useful subset of the whole ontology (everything that can be covered by OBO format). OBO format has that speaking for it: it is very easy to review!</li> <li><code>mwo-base.owl</code> - this reflects the asserted axioms in your ontology that you have actually edited.</li> <li>Ideally also take a look at <code>mwo-full.owl</code>, which may reveal interesting new inferences you did not know about. Note that the diff of this file is sometimes quite large.</li> </ol> </li> <li>Like with every pull request, we recommend to always employ a second set of eyes when reviewing a PR!</li> </ol>"},{"location":"odk-workflows/ReleaseWorkflow/#merge-the-main-branch","title":"Merge the main branch","text":"<p>Once your CI checks have passed, and your reviews are completed, you can now merge the branch into your main branch (don't forget to delete the branch afterwards - a big button will appear after the merge is finished).</p>"},{"location":"odk-workflows/ReleaseWorkflow/#create-a-github-release","title":"Create a GitHub release","text":"<ol> <li>Go to your releases page on GitHub by navigating to your repository, and then clicking on releases (usually on the right, for example: https://github.com/ISE-FIZKarlsruhe/MatWerk_ontology/releases). Then click \"Draft new release\"</li> <li>As the tag version you need to choose the date on which your ontologies were build. You can find this, for example, by looking at the <code>mwo.obo</code> file and check the <code>data-version:</code> property. The date needs to be prefixed with a <code>v</code>, so, for example <code>v2020-02-06</code>.</li> <li>You can write whatever you want in the release title, but we typically write the date again. The description underneath should contain a concise list of changes or term additions.</li> <li>Click \"Publish release\". Done.</li> </ol>"},{"location":"odk-workflows/ReleaseWorkflow/#debugging-typical-ontology-release-problems","title":"Debugging typical ontology release problems","text":""},{"location":"odk-workflows/ReleaseWorkflow/#problems-with-memory","title":"Problems with memory","text":"<p>When you are dealing with large ontologies, you need a lot of memory. When you see error messages relating to large ontologies such as CHEBI, PRO, NCBITAXON, or Uberon, you should think of memory first, see here.</p>"},{"location":"odk-workflows/ReleaseWorkflow/#problems-when-using-obo-format-based-tools","title":"Problems when using OBO format based tools","text":"<p>Sometimes you will get cryptic error messages when using legacy tools using OBO format, such as the ontology release tool (OORT), which is also available as part of the ODK docker container. In these cases, you need to track down what axiom or annotation actually caused the breakdown. In our experience (in about 60% of the cases) the problem lies with duplicate annotations (<code>def</code>, <code>comment</code>) which are illegal in OBO. Here is an example recipe of how to deal with such a problem:</p> <ol> <li>If you get a message like <code>make: *** [cl.Makefile:84: oort] Error 255</code> you might have a OORT error. </li> <li>To debug this, in your terminal enter <code>sh run.sh make IMP=false PAT=false oort -B</code> (assuming you are already in the ontology folder in your directory) </li> <li>This should show you where the error is in the log (eg multiple different definitions)  WARNING: THE FIX BELOW IS NOT IDEAL, YOU SHOULD ALWAYS TRY TO FIX UPSTREAM IF POSSIBLE</li> <li>Open <code>mwo-edit.owl</code> in Prot\u00e9g\u00e9 and find the offending term and delete all offending issue (e.g. delete ALL definition, if the problem was \"multiple def tags not allowed\") and save.  *While this is not idea, as it will remove all definitions from that term, it will be added back again when the term is fixed in the ontology it was imported from and added back in.</li> <li>Rerun <code>sh run.sh make IMP=false PAT=false oort -B</code> and if it all passes, commit your changes to a branch and make a pull request as usual.</li> </ol>"},{"location":"odk-workflows/RepoManagement/","title":"Managing your ODK repository","text":""},{"location":"odk-workflows/RepoManagement/#updating-your-odk-repository","title":"Updating your ODK repository","text":"<p>Your ODK repositories configuration is managed in <code>src/ontology/mwo-odk.yaml</code>. The ODK Project Configuration Schema defines all possible parameters that can be used in this config YAML. Once you have made your changes, you can run the following to apply your changes to the repository:</p> <pre><code>sh run.sh make update_repo\n</code></pre> <p>There are a large number of options that can be set to configure your ODK, but we will only discuss a few of them here.</p> <p>NOTE for Windows users:</p> <p>You may get a cryptic failure such as <code>Set Illegal Option -</code> if the update script located in <code>src/scripts/update_repo.sh</code>  was saved using Windows Line endings. These need to change to unix line endings. In Notepad++, for example, you can  click on Edit-&gt;EOL Conversion-&gt;Unix LF to change this.</p>"},{"location":"odk-workflows/RepoManagement/#managing-imports","title":"Managing imports","text":"<p>You can use the update repository workflow described on this page to perform the following operations to your imports:</p> <ol> <li>Add a new import</li> <li>Modify an existing import</li> <li>Remove an import you no longer want</li> <li>Customise an import</li> </ol> <p>We will discuss all these workflows in the following.</p>"},{"location":"odk-workflows/RepoManagement/#add-new-import","title":"Add new import","text":"<p>To add a new import, you first edit your odk config as described above, adding an <code>id</code> to the <code>product</code> list in the <code>import_group</code> section (for the sake of this example, we assume you already import RO, and your goal is to also import GO):</p> <pre><code>import_group:\n  products:\n    - id: ro\n    - id: go\n</code></pre> <p>Note: our ODK file should only have one <code>import_group</code> which can contain multiple imports (in the <code>products</code> section). Next, you run the update repo workflow to apply these changes. Note that by default, this module is going to be a SLME Bottom module, see here. To change that or customise your module, see section \"Customise an import\". To finalise the addition of your import, perform the following steps:</p> <ol> <li>Add an import statement to your <code>src/ontology/mwo-edit.owl</code> file. We suggest to do this using a text editor, by simply copying an existing import declaration and renaming it to the new ontology import, for example as follows:     <code>...     Ontology(&lt;http://purls.helmholtz-metadaten.de/mwo/mwo.owl&gt;     Import(&lt;http://purls.helmholtz-metadaten.de/mwo/mwo/imports/ro_import.owl&gt;)     Import(&lt;http://purls.helmholtz-metadaten.de/mwo/mwo/imports/go_import.owl&gt;)     ...</code></li> <li>Add your imports redirect to your catalog file <code>src/ontology/catalog-v001.xml</code>, for example:     <code>&lt;uri name=\"http://purl.obolibrary.org/obo/mwo/imports/go_import.owl\" uri=\"imports/go_import.owl\"/&gt;</code></li> <li>Test whether everything is in order:<ol> <li>Refresh your import</li> <li>Open in your Ontology Editor of choice (Protege) and ensure that the expected terms are imported.</li> </ol> </li> </ol> <p>Note: The catalog file <code>src/ontology/catalog-v001.xml</code> has one purpose: redirecting  imports from URLs to local files. For example, if you have</p> <pre><code>Import(&lt;http://purl.obolibrary.org/obo/mwo/imports/go_import.owl&gt;)\n</code></pre> <p>in your editors file (the ontology) and</p> <pre><code>&lt;uri name=\"http://purls.helmholtz-metadaten.de/mwo/mwo/imports/go_import.owl\" uri=\"imports/go_import.owl\"/&gt;\n</code></pre> <p>in your catalog, tools like <code>robot</code> or Prot\u00e9g\u00e9 will recognize the statement in the catalog file to redirect the URL <code>http://purl.obolibrary.org/obo/mwo/imports/go_import.owl</code> to the local file <code>imports/go_import.owl</code> (which is in your <code>src/ontology</code> directory).</p>"},{"location":"odk-workflows/RepoManagement/#modify-an-existing-import","title":"Modify an existing import","text":"<p>If you simply wish to refresh your import in light of new terms, see here. If you wish to change the type of your module see section \"Customise an import\".</p>"},{"location":"odk-workflows/RepoManagement/#remove-an-existing-import","title":"Remove an existing import","text":"<p>To remove an existing import, perform the following steps:</p> <ol> <li>remove the import declaration from your <code>src/ontology/mwo-edit.owl</code>.</li> <li>remove the id from your <code>src/ontology/mwo-odk.yaml</code>, eg. <code>- id: go</code> from the list of <code>products</code> in the <code>import_group</code>.</li> <li>run update repo workflow</li> <li>delete the associated files manually:<ul> <li><code>src/imports/go_import.owl</code></li> <li><code>src/imports/go_terms.txt</code></li> </ul> </li> <li>Remove the respective entry from the <code>src/ontology/catalog-v001.xml</code> file.</li> </ol>"},{"location":"odk-workflows/RepoManagement/#customise-an-import","title":"Customise an import","text":"<p>By default, an import module extracted from a source ontology will be a SLME module, see here. There are various options to change the default.</p> <p>The following change to your repo config (<code>src/ontology/mwo-odk.yaml</code>) will switch the go import from an SLME module to a simple ROBOT filter module:</p> <pre><code>import_group:\n  products:\n    - id: ro\n    - id: go\n      module_type: filter\n</code></pre> <p>A ROBOT filter module is, essentially, importing all external terms declared by your ontology (see here on how to declare external terms to be imported). Note that the <code>filter</code> module does  not consider terms/annotations from namespaces other than the base-namespace of the ontology itself. For example, in the example of GO above, only annotations / axioms related to the GO base IRI (http://purl.obolibrary.org/obo/GO_) would be considered. This  behaviour can be changed by adding additional base IRIs as follows:</p> <pre><code>import_group:\n  products:\n    - id: go\n      module_type: filter\n      base_iris:\n        - http://purl.obolibrary.org/obo/GO_\n        - http://purl.obolibrary.org/obo/CL_\n        - http://purl.obolibrary.org/obo/BFO\n</code></pre> <p>If you wish to customise your import entirely, you can specify your own ROBOT command to do so. To do that, add the following to your repo config (<code>src/ontology/mwo-odk.yaml</code>):</p> <pre><code>import_group:\n  products:\n    - id: ro\n    - id: go\n      module_type: custom\n</code></pre> <p>Now add a new goal in your custom Makefile (<code>src/ontology/mwo.Makefile</code>, not <code>src/ontology/Makefile</code>).</p> <pre><code>imports/go_import.owl: mirror/ro.owl imports/ro_terms_combined.txt\n    if [ $(IMP) = true ]; then $(ROBOT) query  -i $&lt; --update ../sparql/preprocess-module.ru \\\n        extract -T imports/ro_terms_combined.txt --force true --individuals exclude --method BOT \\\n        query --update ../sparql/inject-subset-declaration.ru --update ../sparql/postprocess-module.ru \\\n        annotate --ontology-iri $(ONTBASE)/$@ $(ANNOTATE_ONTOLOGY_VERSION) --output $@.tmp.owl &amp;&amp; mv $@.tmp.owl $@; fi\n</code></pre> <p>Now feel free to change this goal to do whatever you wish it to do! It probably makes some sense (albeit not being a strict necessity), to leave most of the goal instead and replace only:</p> <pre><code>extract -T imports/ro_terms_combined.txt --force true --individuals exclude --method BOT \\\n</code></pre> <p>to another ROBOT pipeline.</p>"},{"location":"odk-workflows/RepoManagement/#add-a-component","title":"Add a component","text":"<p>A component is an import which belongs to your ontology, e.g. is managed by  you and your team. </p> <ol> <li>Open <code>src/ontology/mwo-odk.yaml</code></li> <li>If you dont have it yet, add a new top level section <code>components</code></li> <li>Under the <code>components</code> section, add a new section called <code>products</code>.  This is where all your components are specified</li> <li>Under the <code>products</code> section, add a new component, e.g. <code>- filename: mycomp.owl</code></li> </ol> <p>Example</p> <pre><code>components:\n  products:\n    - filename: mycomp.owl\n</code></pre> <p>When running <code>sh run.sh make update_repo</code>, a new file <code>src/ontology/components/mycomp.owl</code> will  be created which you can edit as you see fit. Typical ways to edit:</p> <ol> <li>Using a ROBOT template to generate the component (see below)</li> <li>Manually curating the component separately with Prot\u00e9g\u00e9 or any other editor</li> <li>Providing a <code>components/mycomp.owl:</code> make target in <code>src/ontology/mwo.Makefile</code> and provide a custom command to generate the component<ul> <li><code>WARNING</code>: Note that the custom rule to generate the component MUST NOT depend on any other ODK-generated file such as seed files and the like (see issue).</li> </ul> </li> <li>Providing an additional attribute for the component in <code>src/ontology/mwo-odk.yaml</code>, <code>source</code>, to specify that this component should simply be downloaded from somewhere on the web.</li> </ol>"},{"location":"odk-workflows/RepoManagement/#adding-a-new-component-based-on-a-robot-template","title":"Adding a new component based on a ROBOT template","text":"<p>Since ODK 1.3.2, it is possible to simply link a ROBOT template to a component without having to specify any of the import logic. In order to add a new component that is connected to one or more template files, follow these steps:</p> <ol> <li>Open <code>src/ontology/mwo-odk.yaml</code>.</li> <li>Make sure that <code>use_templates: TRUE</code> is set in the global project options. You should also make sure that <code>use_context: TRUE</code> is set in case you are using prefixes in your templates that are not known to <code>robot</code>, such as <code>OMOP:</code>, <code>CPONT:</code> and more. All non-standard prefixes you are using should be added to <code>config/context.json</code>.</li> <li>Add another component to the <code>products</code> section.</li> <li>To activate this component to be template-driven, simply say: <code>use_template: TRUE</code>. This will create an empty template for you in the templates directory, which will automatically be processed when recreating the component (e.g. <code>run.bat make recreate-mycomp</code>).</li> <li>If you want to use more than one component, use the <code>templates</code> field to add as many template names as you wish. ODK will look for them in the <code>src/templates</code> directory.</li> <li>Advanced: If you want to provide additional processing options, you can use the <code>template_options</code> field. This should be a string with option from robot template. One typical example for additional options you may want to provide is <code>--add-prefixes config/context.json</code> to ensure the prefix map of your context is provided to <code>robot</code>, see above.</li> </ol> <p>Example:</p> <pre><code>components:\n  products:\n    - filename: mycomp.owl\n      use_template: TRUE\n      template_options: --add-prefixes config/context.json\n      templates:\n        - template1.tsv\n        - template2.tsv\n</code></pre> <p>Note: if your mirror is particularly large and complex, read this ODK recommendation.</p>"},{"location":"odk-workflows/RepositoryFileStructure/","title":"Repository structure","text":"<p>The main kinds of files in the repository:</p> <ol> <li>Release files</li> <li>Imports</li> <li>Components</li> </ol>"},{"location":"odk-workflows/RepositoryFileStructure/#release-files","title":"Release files","text":"<p>Release file are the file that are considered part of the official ontology release and to be used by the community. A detailed description of the release artefacts can be found here.</p>"},{"location":"odk-workflows/RepositoryFileStructure/#imports","title":"Imports","text":"<p>Imports are subsets of external ontologies that contain terms and axioms you would like to re-use in your ontology. These are considered \"external\", like dependencies in software development, and are not included in your \"base\" product, which is the release artefact which contains only those axioms that you personally maintain.</p> <p>These are the current imports in MWO</p> Import URL Type iao http://purl.obolibrary.org/obo/iao.owl None pmdco https://raw.githubusercontent.com/materialdigital/core-ontology/refs/heads/develop-3.0.0/pmdco.owl None"},{"location":"odk-workflows/RepositoryFileStructure/#components","title":"Components","text":"<p>Components, in contrast to imports, are considered full members of the ontology. This means that any axiom in a component is also included in the ontology base - which means it is considered native to the ontology. While this sounds complicated, consider this: conceptually, no component should be part of more than one ontology. If that seems to be the case, we are most likely talking about an import. Components are often not needed for ontologies, but there are some use cases:</p> <ol> <li>There is an automated process that generates and re-generates a part of the ontology</li> <li>A part of the ontology is managed in ROBOT templates</li> <li>The expressivity of the component is higher than the format of the edit file. For example, people still choose to manage their ontology in OBO format (they should not) missing out on a lot of owl features. They may choose to manage logic that is beyond OBO in a specific OWL component.</li> </ol>"},{"location":"odk-workflows/SettingUpDockerForODK/","title":"Setting up your Docker environment for ODK use","text":"<p>One of the most frequent problems with running the ODK for the first time is failure because of lack of memory. This can look like a Java OutOfMemory exception,  but more often than not it will appear as something like an <code>Error 137</code>. There are two places you need to consider to set your memory:</p> <ol> <li>Your src/ontology/run.sh (or run.bat) file. You can set the memory in there by adding  <code>robot_java_args: '-Xmx8G'</code> to your src/ontology/mwo-odk.yaml file, see for example here.</li> <li>Set your docker memory. By default, it should be about 10-20% more than your <code>robot_java_args</code> variable. You can manage your memory settings by right-clicking on the docker whale in your system bar--&gt;Preferences--&gt;Resources--&gt;Advanced, see picture below.</li> </ol> <p></p>"},{"location":"odk-workflows/UpdateImports/","title":"Update Imports Workflow","text":"<p>This page discusses how to update the contents of your imports, like adding or removing terms. If you are looking to customise imports, like changing the module type, see here.</p>"},{"location":"odk-workflows/UpdateImports/#importing-a-new-term","title":"Importing a new term","text":"<p>Note: some ontologies now use a merged-import system to manage dynamic imports, for these please follow instructions in the section title \"Using the Base Module approach\".</p> <p>Importing a new term is split into two sub-phases:</p> <ol> <li>Declaring the terms to be imported</li> <li>Refreshing imports dynamically</li> </ol>"},{"location":"odk-workflows/UpdateImports/#declaring-terms-to-be-imported","title":"Declaring terms to be imported","text":"<p>There are three ways to declare terms that are to be imported from an external ontology. Choose the appropriate one for your particular scenario (all three can be used in parallel if need be):</p> <ol> <li>Prot\u00e9g\u00e9-based declaration</li> <li>Using term files</li> <li>Using the custom import template</li> </ol>"},{"location":"odk-workflows/UpdateImports/#protege-based-declaration","title":"Prot\u00e9g\u00e9-based declaration","text":"<p>This workflow is to be avoided, but may be appropriate if the editor does not have access to the ODK docker container.  This approach also applies to ontologies that use base module import approach.</p> <ol> <li>Open your ontology (edit file) in Prot\u00e9g\u00e9 (5.5+).</li> <li>Select 'owl:Thing'</li> <li>Add a new class as usual.</li> <li>Paste the full iri in the 'Name:' field, for example, http://purl.obolibrary.org/obo/CHEBI_50906.</li> <li>Click 'OK'</li> </ol> <p></p> <p>Now you can use this term for example to construct logical definitions. The next time the imports are refreshed (see how to refresh here), the metadata (labels, definitions, etc.) for this term are imported from the respective external source ontology and becomes visible in your ontology.</p>"},{"location":"odk-workflows/UpdateImports/#using-term-files","title":"Using term files","text":"<p>Every import has, by default a term file associated with it, which can be found in the imports directory. For example, if you have a GO import in <code>src/ontology/go_import.owl</code>, you will also have an associated term file <code>src/ontology/go_terms.txt</code>. You can add terms in there simply as a list:</p> <pre><code>GO:0008150\nGO:0008151\n</code></pre> <p>Now you can run the refresh imports workflow) and the two terms will be imported.</p>"},{"location":"odk-workflows/UpdateImports/#using-the-custom-import-template","title":"Using the custom import template","text":"<p>This workflow is appropriate if:</p> <ol> <li>You prefer to manage all your imported terms in a single file (rather than multiple files like in the \"Using term files\" workflow above).</li> <li>You wish to augment your imported ontologies with additional information. This requires a cautionary discussion.</li> </ol> <p>To enable this workflow, you add the following to your ODK config file (<code>src/ontology/mwo-odk.yaml</code>), and update the repository:</p> <pre><code>use_custom_import_module: TRUE\n</code></pre> <p>Now you can manage your imported terms directly in the custom external terms template, which is located at <code>src/templates/external_import.owl</code>. Note that this file is a ROBOT template, and can, in principle, be extended to include any axioms you like. Before extending the template, however, read the following carefully.</p> <p>The main purpose of the custom import template is to enable the management off all terms to be imported in a centralised place. To enable that, you do not have to do anything other than maintaining the template. So if you, say currently import <code>APOLLO_SV:00000480</code>, and you wish to import <code>APOLLO_SV:00000532</code>, you simply add a row like this:</p> <pre><code>ID  Entity Type\nID  TYPE\nAPOLLO_SV:00000480  owl:Class\nAPOLLO_SV:00000532  owl:Class\n</code></pre> <p>When the imports are refreshed see imports refresh workflow, the term(s) will simply be imported from the configured ontologies.</p> <p>Now, if you wish to extend the Makefile (which is beyond these instructions) and add, say, synonyms to the imported terms, you can do that, but you need to (a) preserve the <code>ID</code> and <code>ENTITY</code> columns and (b) ensure that the ROBOT template is valid otherwise, see here.</p> <p>WARNING. Note that doing this is a widespread antipattern (see related issue). You should not change the axioms of terms that do not belong into your ontology unless necessary - such changes should always be pushed into the ontology where they belong. However, since people are doing it, whether the OBO Foundry likes it or not, at least using the custom imports module as described here localises the changes to a single simple template and ensures that none of the annotations added this way are merged into the base file.  </p>"},{"location":"odk-workflows/UpdateImports/#refresh-imports","title":"Refresh imports","text":"<p>If you want to refresh the import yourself (this may be necessary to pass the travis tests), and you have the ODK installed, you can do the following (using go as an example):</p> <p>First, you navigate in your terminal to the ontology directory (underneath src in your hpo root directory). </p> <pre><code>cd src/ontology\n</code></pre> <p>Then, you regenerate the import that will now include any new terms you have added. Note: You must have docker installed.</p> <pre><code>sh run.sh make PAT=false imports/go_import.owl -B\n</code></pre> <p>Since ODK 1.2.27, it is also possible to simply run the following, which is the same as the above:</p> <pre><code>sh run.sh make refresh-go\n</code></pre> <p>Note that in case you changed the defaults, you need to add <code>IMP=true</code> and/or <code>MIR=true</code> to the command below:</p> <pre><code>sh run.sh make IMP=true MIR=true PAT=false imports/go_import.owl -B\n</code></pre> <p>If you wish to skip refreshing the mirror, i.e. skip downloading the latest version of the source ontology for your import (e.g. <code>go.owl</code> for your go import) you can set <code>MIR=false</code> instead, which will do the exact same thing as the above, but is easier to remember:</p> <pre><code>sh run.sh make IMP=true MIR=false PAT=false imports/go_import.owl -B\n</code></pre>"},{"location":"odk-workflows/UpdateImports/#using-the-base-module-approach","title":"Using the Base Module approach","text":"<p>Since ODK 1.2.31, we support an entirely new approach to generate modules: Using base files. The idea is to only import axioms from ontologies that actually belong to it.  A base file is a subset of the ontology that only contains those axioms that nominally  belong there. In other words, the base file does not contain any axioms that belong to another ontology. An example would be this:</p> <p>Imagine this being the full Uberon ontology:</p> <pre><code>Axiom 1: BFO:123 SubClassOf BFO:124\nAxiom 1: UBERON:123 SubClassOf BFO:123\nAxiom 1: UBERON:124 SubClassOf UBERON 123\n</code></pre> <p>The base file is the set of all axioms that are about UBERON terms:</p> <pre><code>Axiom 1: UBERON:123 SubClassOf BFO:123\nAxiom 1: UBERON:124 SubClassOf UBERON 123\n</code></pre> <p>I.e.</p> <pre><code>Axiom 1: BFO:123 SubClassOf BFO:124\n</code></pre> <p>Gets removed.</p> <p>The base file pipeline is a bit more complex than the normal pipelines, because of the logical interactions between the imported ontologies. This is solved by _first  merging all mirrors into one huge file and then extracting one mega module from it.</p> <p>Example: Let's say we are importing terms from Uberon, GO and RO in our ontologies. When we use the base pipelines, we</p> <p>1) First obtain the base (usually by simply downloading it, but there is also an option now to create it with ROBOT) 2) We merge all base files into one big pile 3) Then we extract a single module <code>imports/merged_import.owl</code></p> <p>The first implementation of this pipeline is PATO, see https://github.com/pato-ontology/pato/blob/master/src/ontology/pato-odk.yaml.</p> <p>To check if your ontology uses this method, check src/ontology/mwo-odk.yaml to see if <code>use_base_merging: TRUE</code> is declared under <code>import_group</code></p> <p>If your ontology uses Base Module approach, please use the following steps: </p> <p>First, add the term to be imported to the term file associated with it (see above \"Using term files\" section if this is not clear to you)</p> <p>Next, you navigate in your terminal to the ontology directory (underneath src in your hpo root directory). </p> <pre><code>cd src/ontology\n</code></pre> <p>Then refresh imports by running</p> <pre><code>sh run.sh make imports/merged_import.owl\n</code></pre> <p>Note: if your mirrors are updated, you can run <code>sh run.sh make no-mirror-refresh-merged</code></p> <p>This requires quite a bit of memory on your local machine, so if you encounter an error, it might be a lack of memory on your computer. A solution would be to create a ticket in an issue tracker requesting for the term to be imported, and one of the local devs should pick this up and run the import for you.</p> <p>Lastly, restart Prot\u00e9g\u00e9, and the term should be imported in ready to be used.</p>"},{"location":"odk-workflows/components/","title":"Adding components to an ODK repo","text":"<p>For details on what components are, please see component section of repository file structure document.</p> <p>To add custom components to an ODK repo, please follow the following steps:</p> <p>1) Locate your odk yaml file and open it with your favourite text editor (src/ontology/mwo-odk.yaml) 2) Search if there is already a component section to the yaml file, if not add it accordingly, adding the name of your component:</p> <pre><code>components:\n  products:\n    - filename: your-component-name.owl\n</code></pre> <p>3) Add the component to your catalog file (src/ontology/catalog-v001.xml)</p> <pre><code>  &lt;uri name=\"http://purls.helmholtz-metadaten.de/mwo/mwo/components/your-component-name.owl\" uri=\"components/your-component-name.owl\"/&gt;\n</code></pre> <p>4) Add the component to the edit file (src/ontology/mwo-edit.obo) for .obo formats: </p> <pre><code>import: http://purls.helmholtz-metadaten.de/mwo/mwo/components/your-component-name.owl\n</code></pre> <p>for .owl formats: </p> <pre><code>Import(&lt;http://purls.helmholtz-metadaten.de/mwo/mwo/components/your-component-name.owl&gt;)\n</code></pre> <p>5) Refresh your repo by running <code>sh run.sh make update_repo</code> - this should create a new file in src/ontology/components. 6) In your custom makefile (src/ontology/mwo.Makefile) add a goal for your custom make file. In this example, the goal is a ROBOT template.</p> <pre><code>$(COMPONENTSDIR)/your-component-name.owl: $(SRC) ../templates/your-component-template.tsv \n    $(ROBOT) template --template ../templates/your-component-template.tsv \\\n  annotate --ontology-iri $(ONTBASE)/$@ --output $(COMPONENTSDIR)/your-component-name.owl\n</code></pre> <p>(If using a ROBOT template, do not forget to add your template tsv in src/templates/)</p> <p>7) Make the file by running <code>sh run.sh make components/your-component-name.owl</code></p>"}]}